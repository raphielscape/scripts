#!/usr/bin/env bash
# shellcheck source=/dev/null
#
# Copyright (C) 2018 Raphielscape LLC.
#
# Licensed under the Raphielscape Public License, Version 1.0 (the "License");
# you may not use this file except in compliance with the License.
#
# Environment container

# Export script directory at the beginning
SCRIPTDIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

# Import stack
. "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"/stacks/stackies

# Sourcedir
SRCDIR="${KERNELDIR}"
OUTDIR="${KERNELDIR}/out"

# Parser
PARSE_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
PARSE_ORIGIN="$(git config --get remote.origin.url)"
COMMIT_POINT="$(git log --pretty=format:'%h : %s' -1)"

TELEGRAM_TOKEN=${BOT_API_KEY}

export TELEGRAM_TOKEN PARSE_BRANCH PARSE_ORIGIN COMMIT_POINT SRCDIR OUTDIR

kernelbox() {
    ANYKERNEL="${HOME}/working/AnyKernel2"
    ZIP_DIR="${HOME}/working/weeb_zip"
}

export ANYKERNEL ZIP_DIR KBUILD_BUILD_USER TOOLCHAIN

# Delett Old AnyKernel in Aroma dir if exists
rm -rf "${ANYKERNEL_DONE}"

prepare_clang() {
    header "We're building Clang bois" "${GREEN}"
    
    # Clang configurations
    if [ "${WORKER}" = raphielbox ]; then
        PATH=${HOME}/toolchains/clang-8.x/bin/:$PATH
            if [ "${SELFGCC}" = true ]; then
                PATH=${HOME}/x-tools/aarch64-raph-linux-android/bin:$PATH
                CROSS_COMPILE="aarch64-raph-linux-android-"
            else
                CROSS_COMPILE="aarch64-linux-gnu-"
            fi
        CLANG_TRIPLE="aarch64-linux-gnu-"
    else
        PATH=${HOME}/LLVM/CLANG/bin:$PATH
        PATH=${HOME}/GNU/GCC/bin:$PATH
        CROSS_COMPILE="aarch64-raph-linux-android-"
        CLANG_TRIPLE="aarch64-linux-gnu-"
    fi
    
    CLANG_TCHAIN="${SCRIPTDIR}/ccachewrapper clang"
    CLANG_LD=aarch64-linux-gnu-ld.bfd
    
    # Kbuild Sets
    KBUILD_COMPILER_STRING="$(${CLANG_TCHAIN} --version | head -n 1 |
    perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g')"
    
    # Export compiler for announcer
    COMPILER_USED="$(${CLANG_TCHAIN} --version | head -n 1 |
    perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g')"
    CU=clang
    
    # Scream out the Clang compiler used
    header "Using toolchain: $(${CLANG_TCHAIN} --version | head -n 1 |
    perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g')"
    
    header "Using cross-compiler: $("${CROSS_COMPILE}"gcc --version | head -1)"
}

prepare_gcc() {
    if [ "${WORKER}" = raphielbox ]; then
        COMPILER_USED="$(aarch64-linux-gnu-gcc --version | head -1)"

        # Set Cross Compile
        CROSS_COMPILE="${SCRIPTDIR}/ccachewrapper aarch64-linux-gnu-"

        # Announce what compiler we use
        header "Using toolchain: $(aarch64-linux-gnu-gcc --version | head -1)"
    else
        # Set path for Semaphore GCC location
        PATH=${HOME}/GNU/GCC/bin:$PATH
        COMPILER_USED="$(aarch64-raph-linux-android-gcc --version | head -1)"

        # Set Cross Compile
        CROSS_COMPILE="${SCRIPTDIR}/ccachewrapper aarch64-raph-linux-android-"

        # Announce what compiler we use
        header "Using toolchain: $(aarch64-raph-linux-android-gcc --version | head -1)"
    fi
    
    # Use aarch64-bfd as linker
    GCC_LD=aarch64-linux-gnu-ld.bfd

    # Announce that our current compiler is GCC
    CU=gcc
}

# Examine our compilation threads
# 2x of our available CPUs
CPU="$(grep -c '^processor' /proc/cpuinfo)"
JOBS="$((CPU * 2))"

build() {
    if [ $CU = clang ]; then
        make -j${JOBS} O="${OUTDIR}" CC="${CLANG_TCHAIN}" \
        LD="${CLANG_LD}" HOSTCC="${CLANG_TCHAIN}" \
        HOSTLD="${CLANG_LD}" "$@"
    else
        make -j${JOBS} O="${OUTDIR}" LD="${GCC_LD}" "$@"
    fi
}

# Then export the stuff
export PATH CU COMPILER_USED CLANG_TCHAIN TCHAIN_PATH CLANG_TRIPLE KBUILD_COMPILER_STRING CROSS_COMPILE MAKE

# Whenever build is interrupted by purpose, report it
trap '{
    tg_intstick
    tg_intstickmain
    exit 130
}' INT

# Whenever errors occured, report them
tg_senderror() {
    tg_sendinfo "Build Throwing Error(s)" \
    "@raphielscape naaaaa"
    tg_channelcast "Build Throwing Error(s)"
    [ -n "${STATUS}" ] &&
    exit "${STATUS}" ||
    exit 1
}

# Announce the completion
tg_yay() {
    tg_sendinfo "Compilation for ${DEVICE} Completed yay" \
    "Haha yes"
}

# Fin Prober
fin() {
    header "Yay! My works took $((DIFF / 60)) minute(s) and $((DIFF % 60)) seconds.~"
    tg_sendinfo "Build took $((DIFF / 60)) minute(s) and $((DIFF % 60)) seconds"
    tg_yay
}

# Errored Prober
finerr() {
    header "My works took $((DIFF / 60)) minute(s) and $((DIFF % 60)) seconds but it's error..."
    tg_sendinfo "$(echo -e "Build took $((DIFF / 60)) minute(s) and $((DIFF % 60)) seconds\\nbut it's error...")"
    tg_senderror
    exit 1
}

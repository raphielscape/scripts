#!/usr/bin/env bash
# shellcheck source=/dev/null
#
# Copyright (C) 2019 Raphielscape LLC.
#
# Licensed under the Raphielscape Public License, Version 1.c (the "License");
# you may not use this file except in compliance with the License.
#
# Environment container

# Export script directory at the beginning
SCRIPTDIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

# Import stack
. "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"/stacks/stackies

# Sourcedir
SRCDIR="${KERNELDIR}"
OUTDIR="${KERNELDIR}/out"

# Parser
PARSE_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
PARSE_ORIGIN="$(git config --get remote.origin.url)"
COMMIT_POINT="$(git log --pretty=format:'%h : %s' -1)"

TELEGRAM_TOKEN=${BOT_API_KEY}

# ClangBuiltLinux's tc-build build directory
CBL_DIR=$HOME/scripts/clang-build

export TELEGRAM_TOKEN PARSE_BRANCH PARSE_ORIGIN COMMIT_POINT SRCDIR OUTDIR CBL_DIR

kernelbox() {
    ANYKERNEL="${HOME}/working/AnyKernel2"
    ZIP_DIR="${HOME}/working/weeb_zip"
}

export ANYKERNEL ZIP_DIR KBUILD_BUILD_USER TOOLCHAIN

# Delett Old AnyKernel in Aroma dir if exists
rm -rf "${ANYKERNEL_DONE}"

# Setup GCC Cross-compiler
if [ "${WORKER}" = raphielbox ]; then
    PATH=${HOME}/working/arm-linux-gnueabi-8.x/bin:$PATH
    PATH=${HOME}/x-tools/aarch64-raphiel-elf/bin:$PATH
    LD_LIBRARY_PATH=${HOME}/x-tools/aarch64-raphiel-elf/lib:$LD_LIBRARY_PATH

    if [ "${CC}" = Clang ]; then
        PATH=${HOME}/toolchains/binutils/bin/:$PATH
        PATH=${HOME}/toolchains/clang/bin/:$PATH
        LD_LIBRARY_PATH=${HOME}/toolchains/clang/lib/:$LD_LIBRARY_PATH
        LD_LIBRARY_PATH=${HOME}/toolchains/binutils/lib/:$LD_LIBRARY_PATH
    fi
else
    PATH=/drone/src/armcc/bin:$PATH
    PATH=/drone/src/arm64cc/bin:$PATH
    LD_LIBRARY_PATH=/drone/src/armcc/lib/:$LD_LIBRARY_PATH
    LD_LIBRARY_PATH=/drone/src/arm64cc/lib/:$LD_LIBRARY_PATH
fi

export PATH LD_LIBRARY_PATH

prepare_clang() {
    header "We're building Clang bois" "${GREEN}"

    # Clang configurations
    if [ "${WORKER}" = raphielbox ]; then
        CROSS_COMPILE="aarch64-linux-gnu-"
        CROSS_COMPILE_ARM32="arm-linux-gnueabi-"
    else
        CROSS_COMPILE="aarch64-linux-gnu-"
        CROSS_COMPILE_ARM32="arm-linux-gnueabi-"
    fi

    CLANG_TCHAIN="clang"
    CLANG_TRIPLE="aarch64-linux-gnu-"
    CLANG_LD="ld.lld"
    CLANG_AS="${CROSS_COMPILE}as"

    AR="llvm-ar"
    NM="llvm-nm"
    STRIP="llvm-strip"
    OBJCOPY="llvm-objcopy"
    OBJDUMP="llvm-objdump"
    OBJSIZE="llvm-objsize"

    # Export compiler for announcer
    COMPILER_USED="$(${CLANG_TCHAIN} --version | head -n 1 |
    perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g')"
    LINKER_USED="$(${CLANG_LD} --version | head -1)"
    CU=clang

    # Scream out the Clang compiler used
    header "Using toolchain: $(${CLANG_TCHAIN} --version | head -n 1 |
    perl -pe 's/\(http.*?\)//gs' | sed -e 's/  */ /g')"

    header "Using Linker: $(${CLANG_LD} --version | head -1)"
}

prepare_gcc() {
    # Set Cross Compile
    CROSS_COMPILE_ARM32="arm-linux-gnueabi-"
    CROSS_COMPILE="aarch64-raphiel-elf-"
    COMPILER_USED="$("${CROSS_COMPILE}"gcc --version | head -1)"

    GCC_LD=aarch64-raphiel-elf-ld
    LINKER_USED="$(${GCC_LD} --version | head -1)"

    # Announce what compiler we use
    header "Using cross-compiler: $("${CROSS_COMPILE}"gcc --version | head -1)"

    # Announce that our current compiler is GCC
    CU=gcc
}

# Then export the stuff
export CU COMPILER_USED CLANG_TCHAIN TCHAIN_PATH CLANG_TRIPLE KBUILD_COMPILER_STRING CROSS_COMPILE CROSS_COMPILE_ARM32 MAKE LINKER_USED

build() {
    # Examine our compilation threads
    # 2x of our available CPUs
    CPU="$(grep -c '^processor' /proc/cpuinfo)"
    JOBS="$(( CPU + 4 ))"

    if [ $CU = clang ]; then
        make -j${JOBS} O="${OUTDIR}" CC="${CLANG_TCHAIN}" LD="${CLANG_LD}" AS="${CLANG_AS}" \
        AR="${AR}" AR="${AR}" NM="${NM}" STRIP="${STRIP}" OBJCOPY="${OBJCOPY}" \
        OBJDUMP="${OBJDUMP}" OBJSIZE="${OBJSIZE}" CLANG_TRIPLE="${CLANG_TRIPLE}" "$@"
    else
        make -j${JOBS} O="${OUTDIR}" LD="${GCC_LD}" "$@"
    fi
}

# ClangBuiltLinux's build-llvm.py wrapper
build-clang() {
    local ARCH INSTALL_DIR
    ARCH="AArch64;ARM;X86"
    INSTALL_DIR=${HOME}/toolchains/clang

    [[ ! -f $SCRIPTDIR/clang-build/.git ]] && { warn "Please init the submodule before continuing."; return 1; }
    [[ -d "$INSTALL_DIR" ]] && { rm -rf "${INSTALL_DIR}"-old; mv -f "$INSTALL_DIR"{,-old}; }

    "$SCRIPTDIR"/clang-build/build-llvm.py -B "$CBL_DIR" -I "$INSTALL_DIR" -t $ARCH --lto thin -m native -u --clang-vendor Android
}

# ClangBuiltLinux's build-binutils.py wrapper
build-binutils() {
    local ARCH INSTALL_DIR
    ARCH=( aarch64 arm x86_64 )
    INSTALL_DIR=${HOME}/toolchains/binutils

    [[ ! -f $SCRIPTDIR/clang-build/.git ]] && { warn "Please init the submodule before continuing."; return 1; }
    [[ -d "$INSTALL_DIR" ]] && { rm -rf "${INSTALL_DIR}"-old; mv -f "$INSTALL_DIR"{,-old}; }

    "$SCRIPTDIR"/clang-build/build-binutils.py -B "$CBL_DIR" -I "$INSTALL_DIR" -t "${ARCH[@]}" -u
}

# Whenever build is interrupted by purpose, report it
trap '{
    tg_intgif
    tg_intgifmain
    exit 130
}' INT
